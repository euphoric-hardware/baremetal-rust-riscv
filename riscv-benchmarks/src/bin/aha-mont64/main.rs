#![no_main]
#![no_std]

// generated by chatGPT: https://chatgpt.com/share/67b79395-2dec-8013-bc8c-f6c0e71235f1
/// A structure that encapsulates Montgomery multiplication data.
#[derive(Debug, Clone)]
pub struct Montgomery {
    /// The modulus (must be odd).
    n: u64,
    /// Precomputed value nprime such that n * nprime ≡ -1 mod R.
    nprime: u64,
    /// R = 2^64 as a u128.
    r: u128,
}

impl Montgomery {
    /// Constructs a new Montgomery multiplication context.
    ///
    /// # Panics
    ///
    /// Panics if `n` is even.
    pub fn new(n: u64) -> Self {
        assert!(n % 2 == 1, "Modulus must be odd for Montgomery multiplication.");
        let r = 1u128 << 64; // R = 2^64
        // Compute the modular inverse of n modulo R using an iterative method.
        let n_inv = Self::modinv(n);
        // Set nprime = -n_inv mod R, i.e. nprime = R - n_inv.
        let nprime = (!n_inv).wrapping_add(1);
        Montgomery { n, nprime, r }
    }

    /// Computes the modular inverse of `n` modulo 2^64.
    /// Since `n` is odd, it is invertible modulo 2^64.
    fn modinv(n: u64) -> u64 {
        // Use an iterative refinement (Newton–Raphson) method.
        let mut inv = 1u64;
        // Six iterations suffice for 64-bit numbers.
        for _ in 0..6 {
            inv = inv.wrapping_mul(2u64.wrapping_sub(n.wrapping_mul(inv)));
        }
        inv
    }

    /// Converts `x` into Montgomery form: computes x * R mod n.
    pub fn to_montgomery(&self, x: u64) -> u64 {
        ((x as u128 * self.r) % (self.n as u128)) as u64
    }

    /// Converts a number from Montgomery form back to standard representation.
    /// This is achieved by computing Mont(x, 1) = x * 1 * R^{-1} mod n.
    pub fn from_montgomery(&self, x: u64) -> u64 {
        self.montgomery_mul(x, 1)
    }

    /// Performs Montgomery multiplication.
    ///
    /// Given a and b in Montgomery form, it computes:
    ///   a * b * R^{-1} mod n.
    pub fn montgomery_mul(&self, a: u64, b: u64) -> u64 {
        // Compute the 128-bit product t = a * b.
        let t = a as u128 * b as u128;
        // Compute m = (t mod R) * nprime mod R.
        // Since R = 2^64, t mod R is the lower 64 bits of t.
        let m = ((t as u64).wrapping_mul(self.nprime)) as u64;
        // let m = ((t as u64)*(self.nprime)) as u64;
        // Compute u = (t + m * n) / R.
        let u = (t + (m as u128 * self.n as u128)) >> 64;
        // Ensure the result is reduced modulo n.
        let mut res = u as u64;
        // writeln!(htif::HostFile::stdout(), "=={} {}", u, res).unwrap();
        if res >= self.n {
            // writeln!(htif::HostFile::stdout(), "============={} {}", u, res).unwrap();
            res = res.wrapping_sub(self.n);
        }
        res
    }
}

use riscv_benchmarks::*;
use riscv_rt::entry;

use core::{fmt::Write, ptr::write_volatile};

fn multiply(x: u64, y: u64, m: u64) -> u64 {
    return ((x as u128) * (y as u128) % (m as u128)) as u64;
}

#[entry]
fn main() -> ! {
    let benchmark_data = start_benchmark();
    let in_m = 0xfae849273928f89f;
    let mut in_a = 0x0549372187237fef;
    let in_b:u64 = 0x14736defb9330573;
    for _ in 0..423 {
        // in_a += 1;

        let m = Montgomery::new(in_m);
        let a = m.to_montgomery(in_a);
        let b = m.to_montgomery(in_b);
        let r = m.montgomery_mul(a, b);
        let r = m.montgomery_mul(r, r); // (a*b)^2
        let r = m.montgomery_mul(r, r); // (a*b)^4
        let r = m.from_montgomery(r);
        // unsafe { write_volatile(&mut r, m.from_montgomery(r)); }

        let r2 = multiply(in_a, in_b, in_m);
        let r2 = multiply(r2, r2, in_m);
        let r2 = multiply(r2, r2, in_m);
        // writeln!(htif::HostFile::stdout(), "{}, {}", r2, r).unwrap();
        verify_data(&[r], &[r2]);
    }
    end_benchmark(benchmark_data);
}
